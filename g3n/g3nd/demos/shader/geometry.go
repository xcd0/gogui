package shader

import (
	"github.com/g3n/engine/geometry"
	"github.com/g3n/engine/gls"
	"github.com/g3n/engine/graphic"
	"github.com/g3n/engine/gui"
	"github.com/g3n/engine/light"
	"github.com/g3n/engine/material"
	"github.com/g3n/engine/math32"
	"github.com/g3n/engine/util/helper"
	"github.com/g3n/g3nd/app"
	"time"
)

func init() {
	app.DemoMap["shader.geometry"] = &ShaderGeometry{}
}

type ShaderGeometry struct {
	a             *app.App
	plane         *graphic.Mesh
	box           *graphic.Mesh
	sphere        *graphic.Mesh
	showWireframe int
	showVnormal   int
	showFnormal   int
	rotate        bool
}

// Start is called once at the start of the demo.
func (t *ShaderGeometry) Start(a *app.App) {

	// Add help label
	const help = `Wireframe, vertex and face normals generated by Geometry Shader`
	label1 := gui.NewLabel(help)
	label1.SetFontSize(16)
	label1.SetPosition(10, 10)
	a.DemoPanel().Add(label1)

	// Adds directional front light
	dir1 := light.NewDirectional(&math32.Color{1, 1, 1}, 0.6)
	dir1.SetPosition(0, 0, 100)
	a.Scene().Add(dir1)

	// Create axes helper
	axes := helper.NewAxes(1)
	a.Scene().Add(axes)

	// Registers shaders and program
	a.Renderer().AddShader("shaderGSDemoVertex", sourceGSDemoVertex)
	a.Renderer().AddShader("shaderGSDemoGeometry", sourceGSDemoGeometry)
	a.Renderer().AddShader("shaderGSDemoFrag", sourceGSDemoFrag)
	a.Renderer().AddProgram("progGSDemo", "shaderGSDemoVertex", "shaderGSDemoFrag", "shaderGSDemoGeometry")

	// Creates shared custom material to show normals
	mat := newNormalsMaterial()

	// Adds rectangular plane
	planeGeom := geometry.NewPlane(1, 1)
	mat.Incref()
	t.plane = graphic.NewMesh(planeGeom, mat)
	t.plane.SetPosition(-2.2, 0, 0)
	a.Scene().Add(t.plane)

	// Adds box
	boxGeom := geometry.NewCube(1)
	mat.Incref()
	t.box = graphic.NewMesh(boxGeom, mat)
	t.box.SetPosition(0, 0, 0)
	a.Scene().Add(t.box)

	// Adds sphere
	sphereGeom := geometry.NewSphere(0.8, 4, 4)
	mat.Incref()
	t.sphere = graphic.NewMesh(sphereGeom, mat)
	t.sphere.SetPosition(2.2, 0, 0)
	a.Scene().Add(t.sphere)

	// Add controls
	if a.ControlFolder() == nil {
		return
	}
	t.showWireframe = 1
	t.showVnormal = 1
	t.showFnormal = 1
	t.rotate = true
	g1 := a.ControlFolder().AddGroup("Show")
	cb0 := g1.AddCheckBox("Rotate").SetValue(true)
	cb0.Subscribe(gui.OnChange, func(evname string, ev interface{}) {
		t.rotate = !t.rotate
	})
	cb1 := g1.AddCheckBox("Wireframe").SetValue(true)
	cb1.Subscribe(gui.OnChange, func(evname string, ev interface{}) {
		if t.showWireframe == 0 {
			t.showWireframe = 1
		} else {
			t.showWireframe = 0
		}
		mat.ShowWireframe = t.showWireframe
	})
	cb2 := g1.AddCheckBox("Vertex normals").SetValue(true)
	cb2.Subscribe(gui.OnChange, func(evname string, ev interface{}) {
		if t.showVnormal == 0 {
			t.showVnormal = 1
		} else {
			t.showVnormal = 0
		}
		mat.ShowVnormal = t.showVnormal
	})
	cb3 := g1.AddCheckBox("Face normals").SetValue(true)
	cb3.Subscribe(gui.OnChange, func(evname string, ev interface{}) {
		if t.showFnormal == 0 {
			t.showFnormal = 1
		} else {
			t.showFnormal = 0
		}
		mat.ShowFnormal = t.showFnormal
	})
}

// Update is called every frame.
func (t *ShaderGeometry) Update(a *app.App, deltaTime time.Duration) {

	if t.rotate {
		t.plane.RotateX(0.01)
		t.box.RotateY(0.01)
		t.sphere.RotateZ(0.005)
	}
}

// Cleanup is called once at the end of the demo.
func (t *ShaderGeometry) Cleanup(a *app.App) {}

//
// Normals Custom material
//
type NormalsMaterial struct {
	material.Material // Embedded material
	ShowWireframe     int
	ShowVnormal       int
	ShowFnormal       int
	uniShowWireframe  gls.Uniform
	uniShowVnormal    gls.Uniform
	uniShowFnormal    gls.Uniform
}

func newNormalsMaterial() *NormalsMaterial {

	m := new(NormalsMaterial)
	m.Material.Init()
	m.SetShader("progGSDemo")

	// Creates uniforms
	m.uniShowWireframe.Init("ShowWireframe")
	m.uniShowVnormal.Init("ShowVnormal")
	m.uniShowFnormal.Init("ShowFnormal")

	// Set uniform's initial values
	m.ShowWireframe = 1
	m.ShowVnormal = 1
	m.ShowFnormal = 1
	return m
}

func (m *NormalsMaterial) RenderSetup(gs *gls.GLS) {

	m.Material.RenderSetup(gs)
	gs.Uniform1i(m.uniShowWireframe.Location(gs), int32(m.ShowWireframe))
	gs.Uniform1i(m.uniShowVnormal.Location(gs), int32(m.ShowVnormal))
	gs.Uniform1i(m.uniShowFnormal.Location(gs), int32(m.ShowFnormal))
}

//
// Vertex Shader
// This is pass-through vertex shader which
// sends its input directly to the geometry shader
// without any processing.
//
const sourceGSDemoVertex = `
#include <attributes>

// Outputs for geometry shader
out vec3 vnormal;

void main() {

	gl_Position = vec4(VertexPosition, 1.0);
  	vnormal = VertexNormal;
}

`

//
// Geometry Shader
// This geometry shader receives triangles vertices
// from the vertex shader and generates lines for
// wireframe and/or vertex normals and/or face normals.
//
const sourceGSDemoGeometry = `
layout (triangles) in;
layout (line_strip, max_vertices = 12) out;

// Model uniforms
uniform mat4 MVP;

// Inputs from Vertex Shader
in vec3 vnormal[];

// Inputs uniforms
uniform int ShowWireframe;
uniform int ShowVnormal;
uniform int ShowFnormal;

// Colors
const vec4 colorWire    = vec4(1, 1, 0, 1);
const vec4 colorVnormal = vec4(1, 0, 0, 1);
const vec4 colorFnormal = vec4(0, 0, 1, 1);

// Output color to fragment shader
out vec4 vertex_color;

void main() {

	// Emits triangle's vertices as lines to show wireframe
	if (ShowWireframe != 0) {
		for (int n = 0; n < gl_in.length(); n++) {
			// Vertex position
			gl_Position = MVP * gl_in[n].gl_Position;
			vertex_color = colorWire;
			EmitVertex();
		}
		// Emit first triangle vertex to close the last line strip.
		gl_Position = MVP * gl_in[0].gl_Position;
		vertex_color = colorWire;
		EmitVertex();
		EndPrimitive();
	}

	// Emits lines representing the vertices normals
	if (ShowVnormal != 0) {
		for (int i = 0; i < gl_in.length(); i++) {

			vec3 position = gl_in[i].gl_Position.xyz;
			vec3 normal = vnormal[i];
			
			gl_Position = MVP * vec4(position, 1.0);
			vertex_color = colorVnormal;
			EmitVertex();
			
			gl_Position = MVP * vec4(position + normal * 0.5, 1.0);
			vertex_color = colorVnormal;
			EmitVertex();
			
			EndPrimitive();
		}
	}

	// Emits one line representing the face normal
	if (ShowFnormal != 0) {
		vec3 p0 = gl_in[0].gl_Position.xyz;
		vec3 p1 = gl_in[1].gl_Position.xyz;
		vec3 p2 = gl_in[2].gl_Position.xyz;
	  
		vec3 v0 = p0 - p1;
		vec3 v1 = p2 - p1;
		vec3 faceN = normalize(cross(v1, v0));

		// Center of the triangle
		vec3 center = (p0 + p1 + p2) / 3.0;
	  
		gl_Position = MVP * vec4(center, 1.0);
		vertex_color = colorFnormal;
		EmitVertex();
	  
		gl_Position = MVP * vec4(center + faceN * 0.5, 1.0);
		vertex_color = colorFnormal;
		EmitVertex();
		EndPrimitive();
	}
}

`

//
// Fragment Shader template
//
const sourceGSDemoFrag = `
precision highp float;

in vec4 vertex_color;
out vec4 Out_Color;

void main() {
	Out_Color = vertex_color;
}

`
